import networkx as nx
import geopandas as gpd
import pickle
from tqdm import tqdm
from collections import Counter


def calculate_shortcuts(graph, node):
    """
    Calculate the number of shortcuts that would be added if the node were contracted.
    
    Parameters:
    - graph: The graph object (NetworkX Graph)
    - node: The node to be considered for contraction
    
    Returns:
    - The number of shortcuts created by contracting the node
    """
    predecessors = list(graph.predecessors(node))
    successors = list(graph.successors(node))

    shortcuts = 0
    # Iterate through predecessors and successors to check if a shortcut can be formed
    for pred in predecessors:
        for succ in successors:
            if not graph.has_edge(pred, succ):
                shortcuts += 1
    return shortcuts


def contraction_hierarchy(graph, shortcut_pair, contraction_ratio=0.3):
    """
    Perform contraction hierarchy on the graph by progressively contracting nodes.
    
    Parameters:
    - graph: The graph object (NetworkX Graph)
    - shortcut_pair: A set to store shortcut edges formed during contraction
    - contraction_ratio: Ratio of nodes to contract, default is 0.3
    
    Returns:
    - contracted_graph: The contracted graph with the nodes removed
    - nodes_to_contract: List of nodes that were contracted
    """
    # Initialize the contracted graph as a copy of the original graph
    contracted_graph = graph.copy()

    # Determine the number of nodes to contract based on the specified ratio
    num_to_contract = int(len(graph) * contraction_ratio)

    # List to store nodes that are contracted
    nodes_to_contract = []

    for _ in tqdm(range(num_to_contract), desc="Contracting nodes", unit="node"):
        # Calculate the number of shortcuts for all nodes in the contracted graph
        shortcut_count = {node: calculate_shortcuts(contracted_graph, node) for node in contracted_graph.nodes()}

        # Sort nodes based on the number of shortcuts in ascending order
        sorted_nodes = sorted(shortcut_count.items(), key=lambda x: x[1])

        # Select the node with the least number of shortcuts for contraction
        node_to_contract = sorted_nodes[0][0]
        nodes_to_contract.append(node_to_contract)

        predecessors = list(contracted_graph.predecessors(node_to_contract))
        successors = list(contracted_graph.successors(node_to_contract))

        # Create direct edges between every predecessor and successor of the node
        for pred in predecessors:
            for succ in successors:
                if not contracted_graph.has_edge(pred, succ):
                    contracted_graph.add_edge(pred, succ)
                    shortcut_pair.add((pred, succ))

        # Remove the current node from the graph
        contracted_graph.remove_node(node_to_contract)

    return contracted_graph, nodes_to_contract
