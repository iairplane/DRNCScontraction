#%% 读csv
import pandas as pd
import networkx as nx
import random
import sys
import numpy as np
from tqdm import tqdm
sys.path.append('code')
from config import get_config

#%%
params, _ = get_config()

#%% 读取link
link = pd.read_excel("D:\pythonProject\data\harbin_data\map\Harbin_edges.xlsx", header=0)

#%% 读取node，记录经纬度
nodes = pd.read_excel("D:\pythonProject\data\harbin_data\map\Harbin_nodes.xlsx", header=0)

#%% 构造图 1901 nodes and 5941 edges
G = nx.DiGraph()
for i in range(len(link)):
    G.add_edge(link['u'][i], link['v'][i], weight=link['length'][i])

n = len(G)

distance_matrix = np.zeros((n, n))

# for s in G.nodes():
#     length = nx.single_source_dijkstra_path_length(G, s)
#     for t in length:
#         distance_matrix[s][t] = length[t]

# vertex index
vertex_index = {}

i = 0
for v in G.nodes():
    vertex_index[v] = i
    i += 1

# import pandas as pd

# 假设你已经有了 G.nodes() 和 vertex_index 字典
# 示例字典结构
# G.nodes() 返回节点列表，vertex_index 是将节点映射到序号的字典

# 示例 vertex_index 字典
# vertex_index = {'334304104': 0, '334304160': 1, '334304164': 2, ...}

# 读取存储经纬度的Excel文档
# 读取Excel文件
excel_file = r"D:\pythonProject\data\harbin_data\map\Harbin_nodes.xlsx"  # 注意使用原始字符串表示路径
df = pd.read_excel(excel_file)

# 创建一个空列表，用于存储最终的数据
result_data = []

# 遍历每一行，将符合条件的数据填充到列表中
for idx, row in df.iterrows():
    osmid = row['osmid']
    if osmid in vertex_index:
        vertex_num = vertex_index[osmid]
        latitude = row['latitude']
        longitude = row['longitude']
        result_data.append({'number': vertex_num, 'latitude': latitude, 'longitude': longitude})

# 将列表转换为 DataFrame
result_df = pd.DataFrame(result_data)

# 将结果写入到文本文件（txt），使用逗号分隔
txt_file = r"D:\pythonProject\data\harbin_data\map\Harbin_nodes_number.txt"  # 输出文件路径和名称，使用原始字符串表示路径
result_df.to_csv(txt_file, sep=',', index=False)
print("successful")

for s in G.nodes():
    length = nx.single_source_dijkstra_path_length(G, s)
    s_i = vertex_index[s]
    for t in length:
        t_i = vertex_index[t]
        distance_matrix[s_i][t_i] = length[t]

#%%
np.save("D:\pythonProject\data\harbin_data\data_set\harbin_directed_shortest_distance_matrix_train.npy", distance_matrix)
print("successful")
#%%
# print(G.edges[595, 1603])
#
# #%%
# print(distance_matrix[1603][595])
# print(distance_matrix[595][1603])

# #%% 构造训练集
# # 写训练集
# train = pd.DataFrame(columns=['Node_Start', 'Longitude_Start', 'Latitude_Start', 'Node_End', 'Longitude_End', 'Latitude_End', 'Distance'])
#
# #%%
# for i in tqdm(range(len(nodes))):
#     for j in range(len(nodes)):
#         if i != j:
#             new = [nodes['Node'][i], nodes['Longitude'][i], nodes['Latitude'][i], nodes['Node'][j],
#                    nodes['Longitude'][j], nodes['Latitude'][j],
#                    nx.dijkstra_path_length(G, nodes['Node'][i], nodes['Node'][j])]
#             train.loc[len(train)] = new
#
# #%%
# sample_number = params.nof_samples
# for k in range(sample_number):
#     i = int(random.random()*len(nodes))
#     j = int(random.random()*len(nodes))
#     train = train.append({'Node_Start': nodes['Node'][i], 'Longitude_Start': nodes['Longitude'][i], 'Latitude_Start': nodes['Latitude'][i], 'Node_End': nodes['Node'][j], 'Longitude_End': nodes['Longitude'][j], 'Latitude_End': nodes['Latitude'][j], 'Distance': nx.dijkstra_path_length(G, nodes['Node'][i], nodes['Node'][j])}, ignore_index=True)
#
# #%% 存储训练集
# train.to_csv('data/data_'+str(len(train))+'.csv', index=False)





